"""
Core analyzer functionality for .found files.
"""

from pathlib import Path
from typing import Dict, List, Optional
import struct
import zlib

from .constants import MAGIC_NUMBER, HEADER_SIZE, QUATERNION_SIZE, POSITION_RECORD_SIZE


class FoundFileAnalyzer:
    """
    Core analyzer for .found files generated by the FOUND satellite positioning system.
    
    This class handles the low-level parsing and validation of .found file format.
    """
    
    def __init__(self, file_path: str):
        """
        Initialize the analyzer with a .found file.
        
        Args:
            file_path: Path to the .found file to analyze
        """
        self.file_path = Path(file_path)
        self.header = None
        self.relative_attitude = None
        self.position_records = []
        
    def analyze_file(self) -> Dict:
        """
        Perform complete analysis of the .found file.
        
        Returns:
            Dictionary containing all analyzed data
            
        Raises:
            FileNotFoundError: If the file doesn't exist
            ValueError: If the file format is invalid
        """
        if not self.file_path.exists():
            raise FileNotFoundError(f"File not found: {self.file_path}")
            
        analysis = {
            'file_path': str(self.file_path),
            'file_size': self.file_path.stat().st_size
        }
        
        with open(self.file_path, 'rb') as f:
            # Read and validate header
            analysis['header'] = self._read_header(f)
            
            # Read quaternion (relative attitude)
            analysis['relative_attitude'] = self._read_quaternion(f)
            
            # Read position records
            position_records = []
            for i in range(analysis['header']['num_positions']):
                try:
                    record = self._read_position_record(f)
                    record['index'] = i
                    position_records.append(record)
                except ValueError as e:
                    print(f"Warning: Could not read position record {i}: {e}")
                    break
            
            analysis['position_records'] = position_records
            analysis['positions_read'] = len(position_records)
            
            # Calculate statistics
            analysis['statistics'] = self._calculate_statistics(position_records)
        
        return analysis
    
    def _read_header(self, file_handle) -> Dict:
        """
        Read and parse the DataFileHeader from the file.
        
        Args:
            file_handle: Open file handle to read from
            
        Returns:
            Dictionary containing header information
            
        Raises:
            ValueError: If header is invalid or corrupted
        """
        # Read the complete header
        header_data = file_handle.read(HEADER_SIZE)
        if len(header_data) != HEADER_SIZE:
            raise ValueError("Invalid file: header too short")
            
        # Unpack header fields (all in network byte order - big endian)
        magic, version, num_positions, crc = struct.unpack('>4sIII', header_data)
        
        if magic != MAGIC_NUMBER:
            raise ValueError(f"Invalid magic number: expected {MAGIC_NUMBER}, got {magic}")
        
        # Calculate CRC of the first 12 bytes (excluding CRC field)
        header_for_crc = header_data[:12]
        calculated_crc = zlib.crc32(header_for_crc) & 0xffffffff
        
        header_info = {
            'magic': magic.decode('ascii'),
            'version': version,
            'num_positions': num_positions,
            'crc': crc,
            'calculated_crc': calculated_crc,
            'crc_valid': crc == calculated_crc
        }
        
        self.header = header_info
        return header_info
    
    def _read_quaternion(self, file_handle) -> Dict:
        """
        Read a quaternion (relative attitude) from the file.
        
        Args:
            file_handle: Open file handle to read from
            
        Returns:
            Dictionary containing quaternion components
            
        Raises:
            ValueError: If quaternion data is invalid
        """
        # Read 4 double values (8 bytes each = 32 bytes total)
        quat_data = file_handle.read(QUATERNION_SIZE)
        if len(quat_data) != QUATERNION_SIZE:
            raise ValueError("Invalid file: quaternion data too short")
            
        # Unpack as network byte order doubles
        real, i, j, k = struct.unpack('>dddd', quat_data)
        
        magnitude = (real**2 + i**2 + j**2 + k**2)**0.5
        
        quaternion = {
            'real': real,
            'i': i,
            'j': j,
            'k': k,
            'magnitude': magnitude,
            'is_unit': abs(magnitude - 1.0) < 1e-6
        }
        
        self.relative_attitude = quaternion
        return quaternion
    
    def _read_position_record(self, file_handle) -> Dict:
        """
        Read a single position record (LocationRecord) from the file.
        
        Args:
            file_handle: Open file handle to read from
            
        Returns:
            Dictionary containing timestamp and position
            
        Raises:
            ValueError: If position record data is invalid
        """
        # Read timestamp (8 bytes) + position (3 * 8 bytes) = 32 bytes total
        record_data = file_handle.read(POSITION_RECORD_SIZE)
        if len(record_data) != POSITION_RECORD_SIZE:
            raise ValueError("Invalid file: position record too short")
            
        # Unpack as network byte order: uint64 + 3 doubles
        timestamp, x, y, z = struct.unpack('>Qddd', record_data)
        
        distance = (x**2 + y**2 + z**2)**0.5
        
        return {
            'timestamp': timestamp,
            'position': {
                'x': x,
                'y': y,
                'z': z
            },
            'distance_from_origin': distance
        }
    
    def _calculate_statistics(self, position_records: List[Dict]) -> Optional[Dict]:
        """
        Calculate statistical information about position records.
        
        Args:
            position_records: List of position record dictionaries
            
        Returns:
            Dictionary containing statistics, or None if no records
        """
        if not position_records:
            return None
            
        distances = [r['distance_from_origin'] for r in position_records]
        timestamps = [r['timestamp'] for r in position_records]
        
        statistics = {
            'min_distance': min(distances),
            'max_distance': max(distances),
            'avg_distance': sum(distances) / len(distances),
            'min_timestamp': min(timestamps),
            'max_timestamp': max(timestamps),
            'time_span': max(timestamps) - min(timestamps) if len(timestamps) > 1 else 0,
            'num_records': len(position_records)
        }
        
        # Add derived time information
        if statistics['time_span'] > 0:
            statistics['duration_seconds'] = statistics['time_span'] / 1_000_000
            statistics['average_interval_microseconds'] = statistics['time_span'] / (len(position_records) - 1)
        
        return statistics
